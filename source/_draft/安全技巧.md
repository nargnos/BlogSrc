---
title: 安全技巧
date: 2017-09-19 15:51:24
categories: [学习笔记,安全]
description: 溢出相关
---

_TODO: 原始笔记，内容简练，记录时未记录基础内容。之后可能要再看书补充一些内容，这里内容太少了。_

安全编码
=========================
常见字符串错误有

* 无界字符串复制
将一个无界数据源复制到定长字符数组时
strcpy和strcat都是无界复制操作
可以通过strlen（取字符串字符长度，不包括0）取得长度+1再分配内存
gets和c++的cin也可能会导致越界
可以配置cin::width限制读入长度

* 差一错误
结尾空字符计算长度时忽略，或者循环的时候对结束条件判断错误
一个字符串的结构为 字符串\0 ，strlen只返回前面的部分，声明为数组时会包括后面的\0
0~n，判断i<n的循环共执行n次， 1~n包括n的话有n个数，中间隔了n-1个数，0~n包括n就有n+1个，中间隔了n-0

* 空结尾
字符末尾忽略了空字符
声明数组时填的大小可能会忽略掉最后一个\0导致输出时出错


* 字符串截断
数组长度不足以容纳内容，拷贝字符串到数组时，数组中的字符串截断缺了\0，输出时也会出错，或者会丢失信息


溢出
====================
栈粉碎
------------------------
指的是缓冲区溢出覆盖到执行栈中的数据。
shellcode因为代码注入时通常只是开shell，所以叫shellcode
缓冲区溢出有可能可以导致栈帧被覆盖，这时候如果**覆盖到了栈帧的返回地址**，就可以进行任意跳转
跳转到代码本身其它位置这种形式的攻击（修改了程序控制流的注入称为弧注入）只能获得程序本身控制权，如果要运行任意代码需要注入代码才有用
弧注入留下痕迹很小（覆盖区很小），而且是基于数据的攻击，所以无法通过将内存段属性设置为不可执行的方式来保护
**跳转指针可以写跳到某一函数，这样可以在指针前写该函数的一些参数，跳转过去就相当于用自定义参数调用了该函数**


需要注入的代码可以写在溢出部分跳转数据的后面，这时候可能并不能获得这部分地址，这就需要多做一些处理，首先在栈中执行代码需要关闭DEP，具体写后面
DEP并不能防止溢出，而是禁止栈执行权限，所以不能防止弧注入

**防御**
使用一些缓存策略可以进行预防
分为静态预防策略和动态预防策略

静态分配的缓冲区会假定一个固定大小，一旦被填满就不能再添加任何数据，因为会丢弃数据，所以为了保证完整性需要进行有效性验证处理

动态分配的缓冲区如果对输入不加以限制，会消耗内存，这可以被DoS利用

另外不要用gets这类有溢出风险的函数

微软环境中可以使用strsafe.h中的函数进行操作，它保证所有字符串都是null结尾（甚至被截断时），并且不会越缓冲区边界写

cin>>std::string 是不会有溢出的，string可以动态调整大小（所以有些人喜欢串用来做缓冲区）

编译器调试的时候会提示有溢出，不过要输入导致溢出的数据才行，编译或输入正常数据时，调试是调不出来的

系统在分配栈内存时会加入随机大小的空隙，这样可以使攻击者更难定位栈上的返回地址（ret地址位置不定）

还有一些方式是在栈中加入难以插入（在溢出位置之前添加哨位，出口处判断）或难以伪造（栈中插入随机值，之后检查）的值保护栈
还有就是重排局部变量，将缓冲区放到指针后面，并将函数参数中的指针复制到局部缓冲区变量之前
这些特性在很多编译器都有提供


指针诡计
-------------------------------
只需要区分函数指针和数据指针就行了
可以**通过覆盖函数指针来将程序控制权转移到shellcode**
另外**数据指针可以被修改让程序对任意内存位置赋值**

很难预防指针诡计，这需要在编程阶段消除漏洞

要使溢出能覆盖函数或数据指针，需要满足
* 缓冲区与目标函数或数据指针必须分配在同一个段内
* 缓冲区必须位于比目标指针更低的地址处
* 缓冲区必须可被缓冲区溢出利用


栈粉碎不可能发生于数据段中，但是覆写函数指针在任何内存段都会发生

如果利用缓冲区溢出漏洞时，如果一个指针接下来被用作赋值操作的目的地址，就可以控制该地址达到修改其他内存位置内容的目的，称为**任意内存写**

在32位下因为int跟指针长度一样，所以可以很容易的覆写任意位置的一个地址


还有的一些方式就是iat hook类似的东西了，linux程序也有类似结构
如果任意内存写写的是iat，之后调用一些函数时就可以跳转到shellcode了

在linux中，可定义在main之前之后执行的函数，这些函数是存储为指针形式的，也可以把这一段覆盖，这一段都是一起存在的

**虚指针修改**
虚函数表中的函数指针可以被修改，指向任意函数是可以的，在其它手段失效的情况下可以考虑


atexit函数设置的地址也可以被修改
longjmp得到的存储结构也可以被修改

**异常处理**
windows提供3种形式的异常处理器，操作系统按给定顺序调用它们直到某一个被成功执行（责任链）

1. 向量化异常处理(Vectored exception handling, VEH)，先于结构化异常处理器调用（未被漏洞利用广泛使用所以略掉）
2. 结构化异常处理(Structured ..., SEH)，实现为每函数或每线程的异常处理器（即每个函数或线程都有自己的异常处理器）
3. 系统默认异常处理，全局的异常过滤器和处理器，用于处理整个进程的异常情况，如果前面的都没处理，这个就会被调用

**SEH**
```
typedef struct _EXCEPTION_REGISTRATION_RECORD {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    PEXCEPTION_ROUTINE Handler;
} EXCEPTION_REGISTRATION_RECORD;

NTAPI
EXCEPTION_ROUTINE (
    _Inout_ struct _EXCEPTION_RECORD *ExceptionRecord,
    _In_ PVOID EstablisherFrame,
    _Inout_ struct _CONTEXT *ContextRecord,
    _In_ PVOID DispatcherContext
    );
```
编译器将一个指向EXCEPTION_REGISTRATION_RECORD结构的指针的地址写入fs段寄存器所引用的地址，其结构存储的形式是链表，Handler是回调地址
windows对异常处理器施加几条强制性措施
EXCEPTION_REGISTRATION_RECORD必须在栈上分配
Next必须在高位
其结构必须按双字节边界对齐

一般函数开头会建立这样的栈帧
|Handler|
|前一个Handler，fs:[0]位于函数起始处|
|哨位|
|保存的ebp|
|返回地址|

如果栈变量缓冲区溢出，异常处理地址将可以被覆写为其它地址

除了覆盖函数指针外，还可以替换TEB中的指针
windows已经加入有效性校验功能，但是在很多情况下还是可以被利用[Litchfield 03a]

有些时候程序会使用SetUnhandledExceptionFilter来设置全局未捕获的异常处理函数，如果使用任意内存写就可以把相应地址覆盖，所以编译器为了防范就添加了SAFE SEH的选项来讲地址编码

避免这类漏洞的方法就是降低漏洞进程的权限，并且设置内存区域要么可写要么可执行，但不能两者兼备


动态内存管理
-----------------------------

对malloc或RtlHeap使用不当会造成漏洞，堆中的内存由动态分配器或内存管理器管理

各种内存管理器使用的算法有区别，但是大多是Knuth在《Art of Computer Programming》中所描述的动态存储分配算法变种
Knuth定义了一种动态存储分配器算法，用于对来自一个较大的存储区域可变大小内存块进行分配和释放。

动态存储分配需要维护一个可用空间列表，按照Knuth的描述“通常最好让可用空间自己携带这样的列表”

动态内存管理容易产生缺陷，有：初始化错误、检查返回值失败、对已释放内存写、多次释放同一块内存、不匹配的内存管理函数、混淆标量和数组的使用、不正确使用内存分配函数


**初始化**
malloc分配的内存块是未初始化的，
这样可能在操作敏感信息后，信息残留在内存中可以被再次读到



**检查返回值失败**
当无法分配内存的时候需要处理，哪怕是返回错误信息并结束程序
可以使用nothrow来处理

**对已释放内存写** 
引用已释放内存，写入空闲内存块可能会覆盖并破坏内存管理器的数据结构

**多次释放同一块内存**

**不匹配的内存管理函数** 
无法保证代码能一直正确工作

**混淆标量和数组的使用**
delete[]和delete释放的范围不同的，用错可能会使部分对象调用不到dtor



**不正确使用内存分配函数**
不要用malloc分配0大小的指针


**@ 堆缓冲区溢出**
**这部分要重新看一下，主要是了解内存管理器结构**
对堆缓冲区溢出的利用通常比栈的困难些
主要原理就是破坏内存管理器的数据结构（这需要熟知内存分配管理器才行）

**unlink技术**
可以欺骗unlink往任意位置写入指针大小的数据
当分配的内存块边界标识被覆写时（出现在连续分配几次内存的情况），free操作可能会把攻击者提供的数据写到设定的指针位置，达到任意内存写的效果
可以任意位置写后，写到iat就可以执行了


**frontlint技术**
更难使用，但是更危险，书中说目前没有已知的利用报告

**@ 双重释放**

必须满足相邻内存块是已分配的，这样就不会发生合并
释放第二次时，管理器数据结构被破坏，第二次分配可能会返回同样信息

**@ 写入已释放内存**
跟双重释放类似，具体看书



RtlHeap
---------------------
该函数的数据结构相关信息存储在PEB，PEB维护每个进程的全局变量，并且被每个线程TEB引用，TEB又被fs寄存器引用

可以用PEB获取堆最大数量、实际数量、默认堆位置以及指向包含所有堆位置的数组的指针

总之又是利用覆写指针导致内存管理器合并的时候将数据写到其它位置，具体看书

防止这类攻击可以将分配内存的地址随机化，或添加一些哨位页（无法存取的内存），这样溢出写到临接内存时会出错



整数安全
==============================
在分配内存空间时取strlen，注意有可能会导致取结果整数溢出
（比如假定用char来存储strlen的话，长度大于可表示的最大值时会变成其它值，当这个值较小时分配的空间就不够存储字符串，将原本很长的字符串写入时就能引发溢出）

注意上下溢、符号无符号类型的转换，这会导致内存分配得到的结果不是正确的值
注意数字间的加减乘除运算，和存储类型的范围，这可能导致范围的降级使表述数值错误

注意数组赋值时下标的检查，当是有符号类型时要进行负数检查，因为负数下标也是可以的

外部输入都要检查上下界

格式化输出
==================
printf、sprintf
变参函数导致格式化输出函数的使用中容易产生漏洞
va_list 声明类型
va_start 初始化
va_arg 返回下一个参数的值并递增参数指针
va_end
（原理就是取第一个参数地址一直往下读就是了，按照压栈顺序后面的参数在高位地址，直接递增就可以取到类型，另外必须要_cdecl调用，由调用者恢复栈，函数自己不知道有几个参数进来）

变参函数需要一个固定参数来确定边界


在使用sprintf时，有条件可以发生缓冲区溢出
即使限制了格式输出类型长度仍有可能溢出
比如
```
char outbuf[512];
char buff[512];
sprintf(buff,"xxxx: %.400s",user); // 这里限制了写入字节数，但是可以写入格式字符串
sprintf(outbuf,buffer); // 当buffer是格式字符串时，将会出现问题，可以写 %xxxd，填充outbuf到溢出，然后后面跟上对应的返回地址和shellcode，这样在执行函数时就发生了溢出

```
又比如
```
void Output(char* str)
{
	printf(str);
}
// 写格式字符串的时候就产生错误了，传入%s%s%s%s%s...就可以查看栈内容
```
这个方式可以用来重建栈内存（传入%08x.%08x.%08x...输出16进制），可以进一步进行攻击


覆写内存
用的是%n，其作用是把输出长度写到以参数形式提供的整数地址中
这个就差不多相当于任意位置写了，不过目前编译器调试时禁止了这个参数
因为格式输出有选项可以填充指定个数的字节，所以这类不需要写很长，但是选项对填充大小有限制的，所以要写类似地址的值就比较困难，这时候可以把它拆成字节多次写入就可以了

文件
==========================
linux的符号链接曾经有bug

shellexecute依赖于注册表，运行程序时用createprocess更可靠
